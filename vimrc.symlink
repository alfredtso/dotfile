let s:darwin = has('mac')
let s:os = substitute(system('uname'), '\n', '', '')

" ===== Basic Setting ===== {{{
filetype off
filetype plugin indent on
syntax on
set mat=2
set nocursorline
set ttyfast
set lazyredraw
set laststatus=2
if s:os == 'Darwin'
	set clipboard=unnamed
elseif s:os == 'Linux'
	set clipboard=unnamedplus
endif
set cmdheight=2
set ignorecase
set timeoutlen=500
set visualbell
set backspace=indent,eol,start 
set hidden                     
set incsearch                  
set hlsearch
set ruler                      
set wildmenu                   
set wildmode=full
set number 		       
set colorcolumn=80								
set wildignore+=*/tmp/*,*.so,*.swp,*.zip
set complete=.,b,u,]
set completeopt=menuone,preview	"for built-in complete
set omnifunc=syntaxcomplete
"set dictionary+=/usr/share/dict/words

set backupdir=/tmp//,.
set directory=/tmp//,.
if v:version >= 703
  set undodir=/tmp//,.
endif

augroup vimrc
	autocmd!
augroup END

" ctags
set tags=./tags;/
set mouse=a

" }}}}

if has('nvim')
	let g:node_host_prog= '.nvm/versions/node/v10.15.0/bin/neovim-node-host'
endif

" ===== Vimscript file settings ===== {{{
augroup filetype_vim
	autocmd!
	autocmd FileType vim setlocal foldmethod=marker
augroup END
"}}}
" ===== MAPPINGS ===== {{{
" ============================================================================

" ----------------------------------------------------------------------------
" Basic mappings
" ----------------------------------------------------------------------------

"Key mappings
let mapleader=" "
let maplocalleader =" "

" VIMRC 
nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
nnoremap <leader>pv :PlugInstall<cr>

"Open new line below and above the current line"
nnoremap <leader>o o<esc>
nnoremap <leader>O O<esc>

" Movement in insert mode
"inoremap <C-h> <C-o>h
"inoremap <C-l> <C-o>a
"inoremap <C-j> <C-o>j
"inoremap <C-k> <C-o>k
"inoremap <C-^> <C-o><C-^>
"inoremap <C-d> <ESC>ddi

" Save
inoremap <C-s> <C-O>:update<cr>
nnoremap <C-s> :update<cr>

" Quit
inoremap <C-Q> <esc>:q<cr>
nnoremap <C-Q> :q<cr>
vnoremap <C-Q> <esc>

inoremap jk <Esc>`^
vnoremap jk <Esc>`^ 
" Make y behaves like other capitals
nnoremap Y y$

" qq to record, Q to replay
nnoremap Q @q

if has('nvim')
  tnoremap jk <C-\><C-n>`^
  tnoremap <M-[> <Esc>
  tnoremap <C-v><Esc> <Esc>
endif
" <F1> | NERD Tree
nnoremap <F1> :NERDTreeToggle<cr>

" Tags
nnoremap <C-]> g<C-]>
nnoremap g[ :pop<cr>

" Jump
nnoremap <C-p> <C-i>

" <F2> | Tagbar
if v:version >= 703
  inoremap <F2> <esc>:TagbarToggle<cr>
  nnoremap <F2> :TagbarToggle<cr>
  let g:tagbar_sort = 0
endif

"""Window navigation"""
"nnoremap <C-h> <C-w>h
"nnoremap <C-j> <C-w>j
"nnoremap <C-k> <C-w>k
"nnoremap <C-l> <C-w>l
" ----------------------------------------------------------------------------
" Buffers
" ----------------------------------------------------------------------------
nnoremap ]b :bnext<cr>
nnoremap [b :bprev<cr>

" ----------------------------------------------------------------------------
" Tabs
" ----------------------------------------------------------------------------
nnoremap ]t :tabn<cr>
nnoremap [t :tabp<cr>

" ----------------------------------------------------------------------------
" <tab> / <s-tab> | Circular windows navigation
" ----------------------------------------------------------------------------
nnoremap <tab>   <c-w>w
nnoremap <S-tab> <c-w>W
" ----------------------------------------------------------------------------
" Quickfix
" ----------------------------------------------------------------------------
nnoremap ]q :cnext<cr>zz
nnoremap [q :cprev<cr>zz
nnoremap ]l :lnext<cr>zz
nnoremap [l :lprev<cr>zz
"}}}

" ===== Tab Setting ===== {{{
set smarttab
set tabstop=4           
set softtabstop=4        
set shiftwidth=4          
set shiftround            
" }}}
"=====Indent Setting====="{{{
set autoindent                 " Minimal automatic indenting for any filetype.
set smartindent					"does the right indent most of the time
set cindent				  "stricter rules for c programs
"}}}


if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
      \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
call plug#begin('~/.vim/plugged')

" Color
" Color{{{ "
highlight ColorColumn ctermbg=0 guibg=#5f00ff
set background=dark
colorscheme gruvbox "color theme
Plug 'arcticicestudio/nord-vim'
Plug 'tomasr/molokai'
Plug 'chriskempson/vim-tomorrow-theme'
Plug 'morhetz/gruvbox'
Plug 'yuttie/hydrangea-vim'
Plug 'tyrannicaltoucan/vim-deep-space'
Plug 'AlessandroYorba/Despacio'
Plug 'cocopon/iceberg.vim'
Plug 'w0ng/vim-hybrid'
Plug 'nightsense/snow'
Plug 'nightsense/stellarized'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes' " airline is the statusbar tool
" }}} Co "

" Edit
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-obsession'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-endwise'
Plug 'junegunn/vim-online-thesaurus'
Plug 'iamcco/markdown-preview.nvim', { 'do': ':call mkdp#util#install()', 'for': 'markdown', 'on': 'MarkdownPreview' }
Plug 'junegunn/vim-emoji'
Plug 'honza/vim-snippets'

" Sql
Plug 'tpope/vim-dadbod'

" Git
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-rhubarb'
Plug 'https://github.com/junegunn/vim-github-dashboard.git'

" Plugin-Clojure {{{1 "
" Clojure
Plug 'tpope/vim-fireplace'
Plug 'tpope/vim-classpath'
Plug 'guns/vim-clojure-static'
Plug 'guns/vim-clojure-highlight'
"Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'neoclide/coc.nvim', {'do': { -> coc#util#install() }}
" 1}}} "
" Lint
Plug 'w0rp/ale'

Plug 'junegunn/goyo.vim'
Plug 'godlygeek/tabular'
Plug 'janko-m/vim-test'
Plug '/usr/local/opt/fzf'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' }
Plug 'luochen1990/rainbow'
Plug 'jpalardy/vim-slime'
Plug 'christoomey/vim-tmux-navigator'

"-------------------- Plugin Settings --------------------"
" Airline {{{1 "
let g:airline_theme='base16'
let g:airline#extensions#tabline#enabled = 1
" 1}}} "
" Ale {{{1 
let g:ale_completion_enabled = 1
let g:ale_fix_on_save = 1
" 1}}} "
" Fzf {{{1 "
"""""""""""""""""""""""""""""Fzf"""""""""""""""""""""""""""""
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)
" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
nnoremap <silent> <Leader><Leader> :FzfFiles<CR>
nnoremap <silent> <Leader><Enter>  :FzfBuffers<CR>
" This is the default extra key bindings
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }
let g:fzf_command_prefix = 'Fzf'
" Default fzf layout
" - down / up / left / right
let g:fzf_layout = { 'down': '~40%' }

let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }
" In Neovim, you can set up fzf window using a Vim command
if has('nvim')
  let g:fzf_layout = { 'window': 'enew' }
  let g:fzf_layout = { 'window': '-tabnew' }
  let g:fzf_layout = { 'window': '10split enew' }
endif
" 1}}} "
" RainbowParentheses {{{1 "
let g:rainbow_active = 1
" 1}}} "
" Slime {{{1 "
let g:slime_target = "tmux"
let g:slime_paste_file = "$HOME/.slime_paste"
let g:slime_default_config = {"socket_name": split($TMUX, ",")[0], "target_pane": ":.2"}
" 1}}} "
" Tagbar {{{1 "
let g:tagbar_autoclose = 1

let g:tagbar_type_haskell = {
    \ 'ctagsbin'    : 'hasktags',
    \ 'ctagsargs'   : '-x -c -o-',
    \ 'kinds'       : [
        \  'm:modules:0:1',
        \  'd:data:0:1',
        \  'd_gadt:data gadt:0:1',
        \  'nt:newtype:0:1',
        \  'c:classes:0:1',
        \  'i:instances:0:1',
        \  'cons:constructors:0:1',
        \  'c_gadt:constructor gadt:0:1',
        \  'c_a:constructor accessors:1:1',
        \  't:type names:0:1',
        \  'pt:pattern types:0:1',
        \  'pi:pattern implementations:0:1',
        \  'ft:function types:0:1',
        \  'fi:function implementations:0:1',
        \  'o:others:0:1'
    \ ],
    \ 'sro'          : '.',
    \ 'kind2scope'   : {
        \ 'm'        : 'module',
        \ 'd'        : 'data',
        \ 'd_gadt'   : 'd_gadt',
        \ 'c_gadt'   : 'c_gadt',
        \ 'nt'       : 'newtype',
        \ 'cons'     : 'cons',
        \ 'c_a'      : 'accessor',
        \ 'c'        : 'class',
        \ 'i'        : 'instance'
    \ },
    \ 'scope2kind'   : {
        \ 'module'   : 'm',
        \ 'data'     : 'd',
        \ 'newtype'  : 'nt',
        \ 'cons'     : 'c_a',
        \ 'd_gadt'   : 'c_gadt',
        \ 'class'    : 'ft',
        \ 'instance' : 'ft'
    \ }
\ }
" 1}}} "
" === Coc === {{{
" =====
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

imap <C-l> <Plug>(coc-snippets-expand)
vmap <C-l> <Plug>(coc-snippets-select)

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

"}}}

"-------------------- Others --------------------"
" <F8> | Color scheme selector {{{1 "
function! s:rotate_colors()
  if !exists('s:colors')
    let s:colors = s:colors()
  endif
  let name = remove(s:colors, 0)
  call add(s:colors, name)
  execute 'colorscheme' name
  redraw
  echo name
endfunction
nnoremap <silent> <F7> :call <SID>rotate_colors()<cr> 

function! s:colors(...)
  return filter(map(filter(split(globpath(&rtp, 'colors/*.vim'), "\n"),
        \                  'v:val !~ "^/usr/"'),
        \           'fnamemodify(v:val, ":t:r")'),
        \       '!a:0 || stridx(v:val, a:1) >= 0')
endfunction

function! s:copy_rtf(line1, line2, ...)
  let [ft, cs, nu] = [&filetype, g:colors_name, &l:nu]
  let lines = getline(1, '$')

  tab new
  setlocal buftype=nofile bufhidden=wipe nonumber
  let &filetype = ft
  call setline(1, lines)
  doautocmd BufNewFile filetypedetect

  execute 'colo' get(a:000, 0, 'seoul256-light')
  hi Normal ctermbg=NONE guibg=NONE

  let lines = getline(a:line1, a:line2)
  let indent = repeat(' ', min(map(filter(copy(lines), '!empty(v:val)'), 'len(matchstr(v:val, "^ *"))')))
  call setline(a:line1, map(lines, 'substitute(v:val, indent, "", "")'))

  call tohtml#Convert2HTML(a:line1, a:line2)
  g/^\(pre\|body\) {/s/background-color: #[0-9]*; //
  silent %write !textutil -convert rtf -textsizemultiplier 1.3 -stdin -stdout | ruby -e 'puts STDIN.read.sub(/\\\n}$/m, "\n}")' | pbcopy

  bd!
  tabclose

  let &l:nu = nu
  execute 'colorscheme' cs
endfunction

if s:darwin
  command! -range=% -nargs=? -complete=customlist,s:colors CopyRTF call s:copy_rtf(<line1>, <line2>, <f-args>)
endif
" 1}}} "
" Help in new tabs {{{1 "
" q to quit
function! s:helptab()
  if &buftype == 'help'
    wincmd T
    nnoremap <buffer> q :q<cr>
  endif
endfunction

autocmd vimrc BufEnter *.txt call s:helptab()

"autocmd BufEnter *.md :inoremap <C-l> <c-g>u<Esc>[s1z=`]a<c-g>u
" 1}}} "

"-------------------- FileType --------------------"
"{{{ === Clojure ===
" -----------------------------------------------------------------------------
function! s:lisp_maps()
	nnoremap <buffer> <leader>rq :silent update<bar>Require<cr>
	nnoremap <buffer> <leader>rQ :silent update<bar>Require!<cr>
	nnoremap <buffer> <leader>rt :silent update<bar>RunTests<cr>
endfunction

augroup vimrc
	"autocmd FileType lisp,clojure,scheme RainbowParentheses
	autocmd FileType lisp,clojure,scheme call <sid>lisp_maps()
	autocmd FileType sql vnoremap <buffer> <Leader>d :DB<CR>
	autocmd FileType clojure xnoremap <buffer> <silent> <cr> "cy:Eval <c-r>c<cr>
augroup END

" }}}
" Haskell FileType {{{1 "
augroup filetype_haskell
	autocmd!
	autocmd FileType haskell set softtabstop=2 
	autocmd FileType haskell set shiftwidth=2 
	autocmd FileType haskell set smartindent!
	autocmd FileType haskell set smarttab!
	autocmd FileType haskell set shiftround!
	autocmd FileType haskell set autoindent!
augroup END
" }}} "

" SQL {{{1 "
augroup filetype_sql
	au!
	" this one is which you're most likely to use?
augroup end
" 1}}} "

